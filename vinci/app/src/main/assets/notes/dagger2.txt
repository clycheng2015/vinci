1、基本的注解类型
1.1、Dagger 2的注解：
public @interface Component {
    Class<?>[] modules() default {};
    Class<?>[] dependencies() default {};
}

public @interface Subcomponent {
    Class<?>[] modules() default {};
}

public @interface Module {
    Class<?>[] includes() default {};
}

public @interface Provides {
}

public @interface MapKey {
    boolean unwrapValue() default true;
}

public interface Lazy<T> {
    T get();
}


1.2、定义在 JSR-330 （Java中依赖注入的标准）中注解，其他还有的其它元素

public @interface Inject {
}

public @interface Scope {
}

public @interface Qualifier {
}

2、注解的作用

(被需求的对象，也叫被依赖的对象，其被调用者（需求方）需要，在需求方内实例化，
去当前调用方的DaggerXXXComponent对象对应的XXXModule中寻找,其中会有对应的@Povide注解的与需求相同的返回值类型方法，就是提供者，或者在需求的对象的构造函数中直接使用@Inject注解)，
即我们有两种方式可以提供依赖，一个是注解了@Inject的构造方法，一个是在Module里提供的依赖
2.1、@Inject 注解，标记那些应该被依赖注入框架提供的依赖
作用一
构造器注入：de >@Injectde>使用在类的构造器上，此时表示所有的参数都是通过依赖图表中获取。

public class LoginActivityPresenter {
    
    private LoginActivity loginActivity;
    private UserDataStore userDataStore;
    private UserManager userManager;
    
    @Inject
    public LoginActivityPresenter(LoginActivity loginActivity,
                                  UserDataStore userDataStore,
                                  UserManager userManager) {
        this.loginActivity = loginActivity;
        this.userDataStore = userDataStore;
        this.userManager = userManager;
    }
}

de >@Inject>注解被使用在构造器中也会标记这个类为依赖图表的一部分。这意味着它也可以在我们需要的时候被注入，即类似于构造器参数，也是可以通过依赖图表中获取。
public class LoginActivity extends BaseActivity {

    //注解的字段不能是private和protected的
    @Inject
    LoginActivityPresenter presenter;
    
    //...
}

作用二：属性注入，即给指定的属性（也就是类的对象）作de >@Injectde>注解
public class SplashActivity extends AppCompatActivity {
    
    @Inject
    LoginActivityPresenter presenter;    //属性注入的局限性是我们不能使用private,因为生成的类中需要对属性进行调用赋值。
    @Inject
    AnalyticsManager analyticsManager;  //属性注入的局限性是我们不能使用private,因为生成的类中需要对属性进行调用赋值。
    
    @Override
    protected void onCreate(Bundle bundle) {
        super.onCreate(bundle);

	//在这里调用之前，我们的依赖是null值，必须手动调用这个方法
        getAppComponent().inject(this);
    }
}

作用三：方法注入，即在类的de >publicde>方法中作注解
public class LoginActivityPresenter {
    
    private LoginActivity loginActivity;
    

    //方法的所有参数都是通过依赖图表提供的,除非没有参数的构造函数
    @Inject 
    public LoginActivityPresenter(LoginActivity loginActivity) {
        this.loginActivity = loginActivity;
    }

    @Inject
    public void enableWatches(Watches watches) {
        watches.register(this);    //Watches instance required fully constructed LoginActivityPresenter
    }
}

不大理解这句：但是为什么我们需要方法注入呢？在某些情况下会用到，如当我们希望传入类的当前实例（de >thisde>引用）到被注入的依赖中。方法注入会在构造器调用后马上被调用，所以这表示我们可以传入完全被构造的de >thisde>。

（提供方，相当于供应商的角色，提供需求方依赖（需要）的对象）
2.2、@Module 注解，用于标记提供依赖的类，即标记需要被框架构建的类。
@Module
public class GithubApiModule {
    
    @Provides   //说明下面这个方法可以提供依赖对象
    @Singleton
    OkHttpClient provideOkHttpClient() {
        OkHttpClient okHttpClient = new OkHttpClient();
        okHttpClient.setConnectTimeout(60 * 1000, TimeUnit.MILLISECONDS);
        okHttpClient.setReadTimeout(60 * 1000, TimeUnit.MILLISECONDS);
        return okHttpClient;
    }

    @Provides
    @Singleton
    RestAdapter provideRestAdapter(Application application, OkHttpClient okHttpClient) {
        RestAdapter.Builder builder = new RestAdapter.Builder();
        builder.setClient(new OkClient(okHttpClient))
               .setEndpoint(application.getString(R.string.endpoint));
        return builder.build();
    }
}

2.3、@Provides 注解，用在de >@Modulede>类中。de >@Providesde>会标记Module中那些返回依赖的方法，示例如上。
2.4、@Component 注解，这个注解用在把一切联系在一起的接口上面。通常是de >@Modulede>和de >@Injectde>之间的桥梁。

下面，这里有个使用了两个module的de >@Componentde>例子代码，可以注入依赖到de >GithubClientApplicationde>，并且标记了三个依赖公开可见


@Singleton   //同一个调用者处提供的依赖对象始终只有一个，不同的调用者处则是多个。
@Component(
    modules = {
        AppModule.class,
        GithubApiModule.class
    }
)
public interface AppComponent {

    void inject(GithubClientApplication githubClientApplication);

    Application getApplication();

    AnalyticsManager getAnalyticsManager();

    UserManager getUserManager();
}

de >@Componentde>也可以依赖其它的component，并且使用ActivityScope定义了生命周期。
@ActivityScope
@Component(      
    modules = SplashActivityModule.class,
    dependencies = AppComponent.class
)
public interface SplashActivityComponent {
    SplashActivity inject(SplashActivity splashActivity);

    SplashActivityPresenter presenter();
}

2.5、@Scope 注解，
de >@Scopede>被用于标记自定义的scope注解。简单说它们可以类似单例地标记依赖。被作注解的依赖会变成单例，但是这会与component的生命周期（不是整个应用）关联。但是正如我刚才所说 - 我会在下一篇文章中深入scope。现在值得一提的是所有自定义scope做的是同样的事情（从代码角度）- 它们为对象保持单例。但是他们也会被在图表认证处理中使用，这对尽可能地捕捉图表结构问题是有帮助的。
@Scope
public @interface ActivityScope {
}

步骤1：查找Module中是否存在创建该类的方法。

步骤2：若存在创建类方法，查看该方法是否存在参数

步骤2.1：若存在参数，则按从步骤1开始依次初始化每个参数

步骤2.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束

步骤3：若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数

步骤3.1：若存在参数，则从步骤1开始依次初始化每个参数

步骤3.2：若不存在参数，则直接初始化该类实例，一次依赖注入到此结束